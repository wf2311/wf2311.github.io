id: 201811231839
title: Java操作码助记符
date: 2018-11-23 18:39:11
categories: 
- Java
- JVM
tags: [JVM]
type: 1
---------

_本表内容来自**《Java虚拟机规范（Java SE 8 版）》**第7章_

<table border=0 cellpadding=0 cellspacing=0><tr><td></td><td colspan=2>操作码</td><td>助记码</td><td>指令含义</td></tr><tr><td rowspan=21>常量</td><td>0</td><td>0x00</td><td>nop</td><td>什么都不做</td></tr><tr><td>1</td><td>0x01</td><td>aconst_null</td><td>将null推送至栈顶</td></tr><tr><td>2</td><td>0x02</td><td>iconst_ml</td><td>将int类型-1推送至栈顶</td></tr><tr><td>3</td><td>0x03</td><td>iconst_0</td><td>将int类型0推送至栈顶</td></tr><tr><td>4</td><td>0x04</td><td>iconst_1</td><td>将int类型1推送至栈顶</td></tr><tr><td>5</td><td>0x05</td><td>iconst_2</td><td>将int类型2推送至栈顶</td></tr><tr><td>6</td><td>0x06</td><td>iconst_3</td><td>将int类型3推送至栈顶</td></tr><tr><td>7</td><td>0x07</td><td>iconst_4</td><td>将int类型4推送至栈顶</td></tr><tr><td>8</td><td>0x08</td><td>iconst_5</td><td>将int类型5推送至栈顶</td></tr><tr><td>9</td><td>0x09</td><td>lconst_0</td><td>将long类型0推送至栈顶</td></tr><tr><td>10</td><td>0x0a</td><td>lconst_1</td><td>将long类型1推送至栈顶</td></tr><tr><td>11</td><td>0x0b</td><td>fconst_0</td><td>将float类型0推送至栈顶</td></tr><tr><td>12</td><td>0x0c</td><td>fconst_1</td><td>将float类型1推送至栈顶</td></tr><tr><td>13</td><td>0x0d</td><td>fconst_2</td><td>将float类型2推送至栈顶</td></tr><tr><td>14</td><td>0x0e</td><td>dconst_0</td><td>将double类型0推送至栈顶</td></tr><tr><td>15</td><td>0x0f</td><td>dconst_1</td><td>将double类型1推送至栈顶</td></tr><tr><td>16</td><td>0x10</td><td>bipush</td><td>将单字节的常量值(-128~127)推送至栈顶</td></tr><tr><td>17</td><td>0x11</td><td>sipush</td><td align=left>将一个短整类型常量值(-32768~32767) 推送至栈顶</td></tr><tr><td>18</td><td>0x12</td><td>ldc</td><td align=left>将int、float或String类型常量值从常量池中推送至栈顶</td></tr><tr><td>19</td><td>0x13</td><td>ldc_w</td><td align=left>将int、float 或String类型常量值从常量池中推送至栈顶(宽索引)<span                style='mso-spacerun:yes'>&nbsp;</span></td></tr><tr><td>20</td><td>0x14</td><td>ldc2_w</td><td align=left>将long或double类型常量值从常量池中推送至栈顶(宽索引)</td></tr><tr><td rowspan=33>加载</td><td>21</td><td>0x15</td><td>iload</td><td>将指定的int类型本地变量推送至栈顶</td></tr><tr><td>22</td><td>0x16</td><td>lload</td><td>将指定的long类型本地变量推送至栈顶</td></tr><tr><td>23</td><td>0x17</td><td>fload</td><td>将指定的float类型本地变量推送至栈顶</td></tr><tr><td>24</td><td>0x18</td><td>dload</td><td>将指定的double类型本地变量推送至栈顶</td></tr><tr><td>25</td><td>0x19</td><td>aload</td><td>将指定的引用类型本地变量推送至栈顶</td></tr><tr><td>26</td><td>0xla</td><td>iload_0</td><td>将第1个int类型本地变量推送至栈顶</td></tr><tr><td>27</td><td>0x1b</td><td>iload_1</td><td>将第2个int类型本地变量推送至栈顶</td></tr><tr><td>28</td><td>0x1c</td><td>iload_2</td><td>将第3个int类型本地变量推送至栈顶</td></tr><tr><td>29</td><td>0xld</td><td>iload_3</td><td>将第4个int类型本地变量推送至栈顶</td></tr><tr><td>30</td><td>0xle</td><td>lload_0</td><td>将第1个long类型本地变量推送至栈顶</td></tr><tr><td>31</td><td>0x1f</td><td>lload_1</td><td>将第2个long类型本地变量推送至栈顶</td></tr><tr><td>32</td><td>0x20</td><td>lload_2</td><td>将第3个long类型本地变量推送至栈顶</td></tr><tr><td>33</td><td>0x21</td><td>lload_3</td><td>将第4个long类型本地变量推送至栈顶</td></tr><tr><td>34</td><td>0x22</td><td>fload_0</td><td>将第1个float类型本地变量推送至栈顶</td></tr><tr><td>35</td><td>0x23</td><td>fload_1</td><td>将第2个float类型本地变量推送至栈顶</td></tr><tr><td>36</td><td>0x24</td><td>fload_2</td><td>将第3个float类型本地变量推送至栈顶</td></tr><tr><td>37</td><td>0x25</td><td>fload_3</td><td>将第4个float类型本地变量推送至栈顶</td></tr><tr><td>38</td><td>0x26</td><td>dload_0</td><td>将第1个double类型本地变量推送至栈顶</td></tr><tr><td>39</td><td>0x27</td><td>dload_1</td><td>将第2个double类型本地变量推送至栈顶</td></tr><tr><td>40</td><td>0x28</td><td>dload_2</td><td>将第3个double类型本地变量推送至栈顶</td></tr><tr><td>41</td><td>0x29</td><td>dload_3</td><td>将第4个double类型本地变量推送至栈顶</td></tr><tr><td>42</td><td>0x2a</td><td>aload_0</td><td>将第1个引用类型本地变量推送至栈顶</td></tr><tr><td>43</td><td>0x2b</td><td>aload_1</td><td>将第2个引用类型本地变量推送至栈项</td></tr><tr><td>44</td><td>0x2c</td><td>aload_2</td><td>将第3个引用类型本地变量推送至栈顶</td></tr><tr><td>45</td><td>0x2d</td><td>aload_3</td><td>将第4个引用类型本地变量推送至栈顶</td></tr><tr><td>46</td><td>0x2e</td><td>iaload</td><td>将int类型数组的指定元素推送至栈顶</td></tr><tr><td>47</td><td>0x2f</td><td>laload</td><td>将long类型数组的指定元素推送至栈顶</td></tr><tr><td>48</td><td>0x30</td><td>faload</td><td>将float类型数组的指定元素推送至栈顶</td></tr><tr><td>49</td><td>0x31</td><td>daload</td><td>将double类型数组的指定元素推送至栈顶</td></tr><tr><td>50</td><td>0x32</td><td>aaload</td><td>将引用类型数组的指定元素推送至栈顶</td></tr><tr><td>51</td><td>0x33</td><td>baload</td><td>将boolean或byte类型数组的指定元素推送至栈顶</td></tr><tr><td>52</td><td>0x34</td><td>caload</td><td>将char类型数组的指定元素推送至栈顶</td></tr><tr><td>53</td><td>0x35</td><td>saload</td><td>将short类型数组的指定元素推送至栈顶</td></tr><tr><td rowspan=33 class=xl70>存储</td><td>54</td><td>0x36</td><td>istore</td><td>将栈顶int类型数值存入指定本地变量</td></tr><tr><td>55</td><td>0x37</td><td>lstore</td><td>将栈顶long类型数值存人指定本地变量</td></tr><tr><td>56</td><td>0x38</td><td>fstore</td><td>将栈顶float类型数值存人指定本地变量</td></tr><tr><td>57</td><td>0x39</td><td>dstore</td><td>将栈顶double类型数值存人指定本地变量</td></tr><tr><td>58</td><td>0x3a</td><td>astore</td><td>将栈顶引用类型数值存人指定本地变量</td></tr><tr><td>59</td><td>0x3b</td><td>istore_0</td><td>将栈顶int类型数值存人第1个本地变量</td></tr><tr><td>60</td><td>0x3c</td><td>istore_1</td><td>将栈顶int类型数值存入第2个本地变量</td></tr><tr><td>61</td><td>0x3d</td><td>istore_2</td><td>将栈顶int类型数值存人第3个本地变量</td></tr><tr><td>62</td><td>0x3e</td><td>istore_3</td><td>将栈顶int类型数值存人第4个本地变量</td></tr><tr><td>63</td><td>0x3f</td><td>lstore_0</td><td>将栈顶long类型数值存人第1个本地变量</td></tr><tr><td>64</td><td>0x40</td><td>lstore_1</td><td>将栈顶long类型数值存人第2个本地变量</td></tr><tr><td>65</td><td>0x41</td><td>lstore_2</td><td>将栈顶long类型数值存人第3个本地变量</td></tr><tr><td>66</td><td>0x42</td><td>lstore_3</td><td>将栈顶long类型数值存人第4个本地变量</td></tr><tr><td>67</td><td>0x43</td><td>fstore_0</td><td>将栈顶float类型数值存人第1个本地变量</td></tr><tr><td>68</td><td>0x44</td><td>fstore_1</td><td>将栈顶float类型数值存人第2个本地变量</td></tr><tr><td>69</td><td>0x45</td><td>fstore_2</td><td>将栈顶float类型数值存人第3个本地变量</td></tr><tr><td>70</td><td>0x46</td><td>fstore_3</td><td>将栈顶float类型数值存人第4个本地变量</td></tr><tr><td>71</td><td>0x47</td><td>dstore_0</td><td>将栈顶double类型数值存人第1个本地变量</td></tr><tr><td>72</td><td>0x48</td><td>dstore_1</td><td>将栈顶double类型数值存人第2个本地变量</td></tr><tr><td>73</td><td>0x49</td><td>dstore_2</td><td>将栈顶double类型数值存人第3个本地变量</td></tr><tr><td>74</td><td>0x4a</td><td>dstore_3</td><td>将栈顶double类型数值存人第4个本地变量</td></tr><tr><td>75</td><td>0x4b</td><td>astore_0</td><td>将栈顶引用类型数值存入第1个本地变量</td></tr><tr><td>76</td><td>0x4c</td><td>astore_1</td><td>将栈顶引用类型数值存人第2个本地变量</td></tr><tr><td>77</td><td>0x4d</td><td>astore_2</td><td>将栈顶引用类型数值存入第3个本地变量</td></tr><tr><td>78</td><td>0x4e</td><td>astore_3</td><td>将栈顶引用类型数值存入第4个本地变量</td></tr><tr><td>79</td><td>0x4f</td><td>iastore</td><td>将栈顶int类型数值存人指定数组的指定索引位置</td></tr><tr><td>80</td><td>0x50</td><td>lastore</td><td>将栈顶long类型数值存人指定数组的指定索引位置</td></tr><tr><td>81</td><td>0x51</td><td>fastore</td><td>将栈顶float类型数值存人指定数组的指定索引位置</td></tr><tr><td>82</td><td>0x52</td><td>dastore</td><td>将栈顶double类型数值存人指定数组的指定索引位置</td></tr><tr><td>83</td><td>0x53</td><td>uastore</td><td>将栈顶引用类型数值存人指定数组的指定索引位置</td></tr><tr><td>84</td><td>0x54</td><td>bastore</td><td>将栈顶boolean或byte类型数值存人指定数组的指定索引位置</td></tr><tr><td>85</td><td>0x55</td><td>castore</td><td>将栈顶char类型数值存人指定数组的指定索引位置</td></tr><tr><td>86</td><td>0x56</td><td>sastore</td><td>将栈顶short类型数值存人指定数组的指定索引位置</td></tr><tr><td rowspan=9 class=xl70>栈</td><td>87</td><td>0x57</td><td>pop</td><td>将栈顶数值弹出( 数值不能是long或double类型的)</td></tr><tr><td>88</td><td>0x58</td><td>pop2</td><td>将栈顶的一个long或double类型的数值或两个其他类型的数值弹出</td></tr><tr><td>89</td><td>0x59</td><td>dup</td><td>复制栈顶数值并将复制值压人栈顶</td></tr><tr><td>90</td><td>0x5a</td><td>dup_x1</td><td>复制栈顶值并将其插人栈顶那两个值的下面</td></tr><tr><td>91</td><td>0x5b</td><td>dup_x2</td><td>复制栈顶值并将其插人栈顶那两个或三个值的下面</td></tr><tr><td>92</td><td>0x5c</td><td>dup2</td><td>复制栈顶的一个long或double类型的值，或两个其他类型的值，并将其压人栈顶</td></tr><tr><td>93</td><td>0x5d</td><td>dup2_x1</td><td>复制栈顶的一个或两个值，并将其插人栈顶那两个或三个值的下面</td></tr><tr><td>94</td><td>0x5e</td><td>dup2_x2</td><td>复制栈顶的一个或两个值，并将其插人栈顶那两个、三个或四个值的下面</td></tr><tr><td>95</td><td>0x5f</td><td>swap</td><td>将栈顶的两个数值互换(数值不能是long或double类型的)</td></tr><tr><td rowspan=35>数学</td><td>96</td><td>0x60</td><td>iadd</td><td>将栈顶两int类型数值相加并将结果压人栈顶</td></tr><tr><td>97</td><td>0x61</td><td>ladd</td><td>将栈顶两long类型数值相加并将结果压人栈顶</td></tr><tr><td>98</td><td>0x62</td><td>fadd</td><td>将栈顶两float类型数值相加并将结果压人栈顶</td></tr><tr><td>99</td><td>0x63</td><td>dadd</td><td>将栈顶两double类型数值相加并将结果压人栈顶</td></tr><tr><td>100</td><td>0x64</td><td>isub</td><td>将栈顶两int类型数值相减并将结果压人栈顶</td></tr><tr><td>101</td><td>0x65</td><td>lsub</td><td>将栈顶两long类型数值相减并将结果压人栈顶</td></tr><tr><td>102</td><td>0x66</td><td>fsub</td><td>将栈顶两float类型数值相减并将结果压人栈顶</td></tr><tr><td>103</td><td>0x67</td><td>dsub</td><td>将栈顶两double类型数值相减并将结果压人栈顶</td></tr><tr><td>104</td><td>0x68</td><td>imul</td><td>将栈顶两int类型数值相乘并将结果压人栈顶</td></tr><tr><td>105</td><td>0x69</td><td>lmul</td><td>将栈顶两long类型数值相乘并将结果压人栈顶</td></tr><tr><td>106</td><td>0x6a</td><td>fmul</td><td>将栈顶两float类型数值相乘并将结果压人栈顶</td></tr><tr><td>107</td><td>0x6b</td><td>dmul</td><td>将栈顶两double类型数值相乘并将结果压人栈顶</td></tr><tr><td>108</td><td>0x6c</td><td>idiv</td><td>将栈顶两int类型数值相除并将结果压人栈顶</td></tr><tr><td>109</td><td>0x6d</td><td>ldiv</td><td>将栈顶两long类型数值相除并将结果压人栈顶</td></tr><tr><td>110</td><td>0x6e</td><td>fdiv</td><td>将栈顶两float类型数值相除并将结果压人栈顶</td></tr><tr><td>111</td><td>0x6f</td><td>ddiv</td><td>将栈顶两double类型数值相除并将结果压人栈顶</td></tr><tr><td>112</td><td>0x70</td><td>irem</td><td>将栈顶两int类型数值作取模运算并将结果压人栈顶</td></tr><tr><td>113</td><td>0x71</td><td>lrem</td><td>将栈顶两long类型数值作取模运算并将结果压人栈顶</td></tr><tr><td>114</td><td>0x72</td><td>frem</td><td>将栈顶两float类型数值作取模运算并将结果压人栈顶</td></tr><tr><td>115</td><td>0x73</td><td>drem</td><td>将栈顶两double类型数值作取模运算并将结果压人栈顶</td></tr><tr><td>116</td><td>0x74</td><td>ineg</td><td>将栈顶int类型数值取负并将结果压入栈项</td></tr><tr><td>117</td><td>0x75</td><td>lneg</td><td>将栈顶long类型数值取负并将结果压人栈顶</td></tr><tr><td>118</td><td>0x76</td><td>fineg</td><td>将栈顶float类型数值取负并将结果压人栈顶</td></tr><tr><td>119</td><td>0x77</td><td>dneg</td><td>将栈顶double类型数值取负并将结果压人栈顶</td></tr><tr><td>120</td><td>0x78</td><td>ishl</td><td>将int类型数值左移位指定位数并将结果压人栈项</td></tr><tr><td>121</td><td>0x79</td><td>lshl</td><td>将long类型数值左移位指定位数并将结果压人栈顶</td></tr><tr><td>122</td><td>0x7a</td><td>ishr</td><td>将int类型数值(有符号)右移位指定位数并将结果压入栈顶</td></tr><tr><td>123</td><td>0x7b</td><td>lshr</td><td>将long类型数值(有符号)右移位指定位数并将结果压入栈顶</td></tr><tr><td>124</td><td>0x7c</td><td>iushr</td><td>将int类型数值(无符号)右移位指定位数并将结果压入栈顶</td></tr><tr><td>125</td><td>0x7d</td><td>lushr</td><td>将long类型数值(无符号)右移位指定位数并将结果压入栈顶</td></tr><tr><td>126</td><td>0x7e</td><td>iand</td><td>将栈顶两int类型数值作“按位与”并将结果压人栈顶</td></tr><tr><td>127</td><td>0x7f</td><td>land</td><td>将栈顶两long类型数值作“按位与” 并将结果压人栈顶</td></tr><tr><td>128</td><td>0x80</td><td>ior</td><td>将栈顶两int类型数值作“按位或”并将结果压人栈项</td></tr><tr><td>129</td><td>0x81</td><td>lor</td><td>将栈顶两long类型数值作“按位或”并将结果压人栈顶</td></tr><tr><td>130</td><td>0x82</td><td>ixor</td><td>将栈顶两int类型数值作“按位异或”并将结果压人栈顶</td></tr><tr><td rowspan=15>转换</td><td>131</td><td>0x83</td><td>lxor</td><td>将栈顶两long类型数值作“按位异或”并将结果压人栈顶</td></tr><tr><td>132</td><td>0x84</td><td>iinc</td><td>将指定int类型变量增加指定值(i++，i--, i+=2)</td></tr><tr><td>133</td><td>0x85</td><td>i2l</td><td>将栈顶int类型数值强制转换成long类型数值并将结果压入栈顶</td></tr><tr><td>134</td><td>0x86</td><td>i2f</td><td>将栈顶int类型数值强制转换成float类型数值并将结果压入栈顶</td></tr><tr><td>135</td><td>0x87</td><td>i2d</td><td>将栈顶int类型数值强制转换成double类型数值并将结果压入栈顶</td></tr><tr><td>136</td><td>0x88</td><td>l2i</td><td>将栈顶long类型数值强制转换成int类型数值并将结果压入栈顶</td></tr><tr><td>137</td><td>0x89</td><td>l2f</td><td>将栈顶long类型数值强制转换成float类型数值并将结果压入栈顶</td></tr><tr><td>138</td><td>0x8a</td><td>l2d</td><td>将栈顶long类型数值强制转换成double类型数值并果压入栈顶</td></tr><tr><td>139</td><td>0x8b</td><td>f2i</td><td>将栈顶float类型数值强制转换成int类型数值并将结果压入栈顶</td></tr><tr><td>140</td><td>0x8c</td><td>f2l</td><td>将栈顶float类型数值强制转换成long类型数值并将结果压入栈顶</td></tr><tr><td>141</td><td>0x8d</td><td>f2d</td><td>将栈顶float类型数值强制转换成double类型数值并果压入栈顶</td></tr><tr><td>142</td><td>0x8e</td><td>d2i</td><td>将栈顶double类型数值强制转换成int类型数值并将果压入栈顶</td></tr><tr><td>143</td><td>0x8f</td><td>d2l</td><td>将栈顶double类型数值强制转换成long类型数值并果压入栈顶</td></tr><tr><td>144</td><td>0x90</td><td>d2f</td><td>将栈顶double类型数值强制转换成float类型数值并果压入栈顶</td></tr><tr><td>145</td><td>0x91</td><td>i2b</td><td>将栈顶int类型数值强制转换成byte类型数值并将结果压入栈顶</td></tr><tr><td rowspan=19 class=xl70>比较</td><td>146</td><td>0x92</td><td>i2c</td><td>将栈顶int类型数值强制转换成char类型数值并将结果压入栈顶</td></tr><tr><td>147</td><td>0x93</td><td>i2s</td><td>将栈顶int类型数值强制转换成short类型数值并将结果压入栈顶</td></tr><tr><td>148</td><td>0x94</td><td>lcmp</td><td>比较栈顶两long类型数值大小，并将结果( 1, 0, -1)压入栈顶</td></tr><tr><td>149</td><td>0x95</td><td>fcmpl</td><td>比较栈顶两float类型数值大小，并将结果(1, 0, -1)压入栈顶;当其中-一个数值为“NaN&quot;时，将-1压入栈顶</td></tr><tr><td>150</td><td>0x96</td><td>fcmpg</td><td>比较栈顶两float类型数值大小，并将结果(1，0, -1)压入栈顶;当其中-一个数值为“NaN&quot;时，将1压入栈顶</td></tr><tr><td>151</td><td>0x97</td><td>dcmpl</td><td>比较栈顶两double类型数值大小，并将结果(1,0,-1)压入栈顶;当其中-一个数值为“NaN&quot;时，将-1压入栈顶</td></tr><tr><td>152</td><td>0x98</td><td>dcmpg</td><td>比较栈顶两double类型数值大小，并将结果(1.0,-1)压入栈顶;当其中一个数值为“NaN&quot; 时，将1压入栈顶</td></tr><tr><td>153</td><td>0x99</td><td>ifeq</td><td>当栈顶int类型数值等于0时跳转</td></tr><tr><td>154</td><td>0x9a</td><td>ifne</td><td>当栈顶int类型数值不等于0时跳转</td></tr><tr><td>155</td><td>0x9b</td><td>jft</td><td>当栈顶int类型数值小于0时跳转</td></tr><tr><td>156</td><td>0x9c</td><td>ifge</td><td>当栈顶int类型数值大于等于0时跳转</td></tr><tr><td>157</td><td>0x9d</td><td>ifgt</td><td>当栈顶int类型数值大于0时跳转</td></tr><tr><td>158</td><td>0x9e</td><td>ifle</td><td>当栈顶int类型数值小于等于0时跳转</td></tr><tr><td>159</td><td>0x9f</td><td>if_icmpeq</td><td>比较栈顶两int类型数值大小，当前者等于后者时跳转</td></tr><tr><td>160</td><td>0xa0</td><td>f_icmpne</td><td>比较栈顶两int类型数值大小，当前者不等于后者时跳转</td></tr><tr><td>161</td><td>0xa1</td><td>if_icmplt</td><td>比较栈顶两int类型数值大小，当前者小于后者时跳转</td></tr><tr><td>162</td><td>0xa2</td><td>if_icmpge</td><td>比较栈顶两int类型数值大小，当前者大于等于后者时跳转</td></tr><tr><td>163</td><td>0xa3</td><td>if_icmpgt</td><td>比较栈顶两int类型数值大小，当前者大于后者时跳转</td></tr><tr><td>164</td><td>0xa4</td><td>if_icmple</td><td>比较栈顶两int类型数值大小，当前者小于等于后者时跳转</td></tr><tr><td rowspan=11>控制</td><td>165</td><td>0xa5</td><td>if_acmpeq</td><td>比较栈顶两引用类型数值，当结果相等时跳转</td></tr><tr><td>166</td><td>0xa6</td><td>if_acmpne</td><td>比较栈顶两引用类型数值，当结果不相等时跳转</td></tr><tr><td>167</td><td>0xa 7</td><td>goto</td><td>无条件跳转</td></tr><tr><td>168</td><td>0xa8</td><td>jsr</td><td>跳转至指定16位offset位置，并将jsr下一条指令地址压入栈顶</td></tr><tr><td>169</td><td>0xa9</td><td>ret</td><td>返回至由指定的局部变量所给出的指令位置(一般与jsr、jsr_w联合使用)</td></tr><tr><td>170</td><td>0xaa</td><td>tableswitch</td><td>用于switch条件跳转，case值连续(变长指令)</td></tr><tr><td>171</td><td>0xab</td><td>lookupswitch</td><td>用于switch条件跳转，case 值不连续(变长指令)</td></tr><tr><td>172</td><td>0xac</td><td>ireturn</td><td>从当前方法返回int</td></tr><tr><td>173</td><td>0xad</td><td>lreturn</td><td>从当前方法返回long</td></tr><tr><td>174</td><td>0xae</td><td>freturn</td><td>从当前方法返回float</td></tr><tr><td>175</td><td>0xaf</td><td>dreturn</td><td>从当前方法返回double</td></tr><tr><td rowspan=18>引用</td><td>176</td><td>0xb0</td><td>areturn</td><td>从当前方法返回对象引用</td></tr><tr><td>177</td><td>0xb1</td><td>return</td><td>从当前方法返回void</td></tr><tr><td>178</td><td>0xb2</td><td>getstatic</td><td>获取指定类的静态字段，并将其值压人栈顶</td></tr><tr><td>179</td><td>0xb3</td><td>putstatic</td><td>为指定类的静态字段赋值</td></tr><tr><td>180</td><td>0xb4</td><td>getfield</td><td>获取指定类的实例字段，并将其值压人栈顶</td></tr><tr><td>181</td><td>0xb5</td><td>pufield</td><td>为指定类的实例字段赋值</td></tr><tr><td>182</td><td>0xb6</td><td>invokevirtual</td><td>调用实例方法</td></tr><tr><td>183</td><td>0xb7</td><td>invokespecial</td><td>调用父类方法、实例初始化方法、私有方法</td></tr><tr><td>184</td><td>0xb8</td><td>invokestatic</td><td>调用静态方法</td></tr><tr><td>185</td><td>0xb9</td><td>invokeinterface</td><td>调用接口方法</td></tr><tr><td>186</td><td>0xba</td><td>invokedynamic</td><td>调用动态链接方法</td></tr><tr><td>187</td><td>0xbb</td><td>new</td><td>创建一个对象，并将其引用值压人栈顶</td></tr><tr><td>188</td><td>0xbc</td><td>newarray</td><td>创建一个指定原始类型(如int、float、char等)的数组，并将其引用值压人栈顶</td></tr><tr><td>189</td><td>0xbd</td><td>anewarray</td><td>创建一个引用型(如类、接口、数组)的数组，并将其引用值压人栈顶</td></tr><tr><td>190</td><td>0xbe</td><td>arraylength</td><td>获得数组的长度值并压人栈顶</td></tr><tr><td>191</td><td>0xbf</td><td>athrow</td><td>将栈顶的异常抛出</td></tr><tr><td>192</td><td>0xc0</td><td>checkcast</td><td>检验类型转换，检验未通过将抛出ClassCastException</td></tr><tr><td>193</td><td>0xc1</td><td>instanceof</td><td>检验对象是否是指定类的实例，如果是，就将1压人栈顶，否则将0压人栈顶</td></tr><tr><td rowspan=8>扩展</td><td>194</td><td>0xc2</td><td>monitorenter</td><td>获得对象的锁，用于实现同步块</td></tr><tr><td>195</td><td>0xc3</td><td>monitorexit</td><td>释放对象的锁，用于实现同步块</td></tr><tr><td>196</td><td>0xc4</td><td>wide</td><td>扩展本地变量索引的宽度</td></tr><tr><td>197</td><td>0xc5</td><td>multianewarray</td><td>创建指定类型和指定维度的多维数组(执行该指令时，操作栈中必须包含各维度的长度值)，并将其引用值压人栈项</td></tr><tr><td>198</td><td>0xc6</td><td>ifnull</td><td>为null时跳转</td></tr><tr><td>199</td><td>0xc7</td><td>ifnonnull</td><td>不为null时跳转</td></tr><tr><td>200</td><td>0xc8</td><td>goto_w</td><td>无条件跳转(宽索引)</td></tr><tr><td>201</td><td>0xc9</td><td>jsr_w</td><td>跳转至指定32位offset位置，并将jsr_w下一条指令地址压人栈顶</td></tr><tr><td rowspan=3>保留字段</td><td>202</td><td>0xca</td><td>breakpoint</td><td>调试时的断点标记</td></tr><tr><td>254</td><td>0xfe</td><td>impdep1</td><td>为特定软件而预留的语言后门</td></tr><tr><td>255</td><td>0xff</td><td>impdep2</td><td>为特定硬件而预留的语言后门</td></tr></table>
